# 10844 : 쉬운 계단 수
# https://www.acmicpc.net/problem/10844
# 인접한 모든 자리의 차이가 1인 수를 계단 수라고 부름

import sys

input = sys.stdin.readline

N = int(input())

# 각 자릿수 별로 가장 뒤에 오는 숫자를 기준으로 확인한다면...?
# 각 자릿수에 대한 DP 테이블
dp = [[0] * 10 for _ in range(N + 1)]

# N=1일 경우에 대한 경우의 수는 전부 1개이므로 초기화
for i in range(1, 10):
    dp[1][i] = 1

# N=2 이상인 경우에 대해 탐색
for i in range(2, N+1): # N 자릿수에 대해서
    for j in range(10): # 해당 자릿수의 맨 뒷자리 수에 따라 분기처리
        # 가장 뒷 자리 수 = 0 
        if j == 0:
            dp[i][j] = dp[i-1][1]
        # 가장 뒷 자리 수 = 9
        elif j == 9:
            dp[i][j] = dp[i-1][8]
        # 가장 뒷 자리 수 = 1 ~ 8
        else:
            dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]

print(sum(dp[N]) % 1000000000)

"""
0로 끝나서 끝 숫자에 -1하는 것은 불가능 즉 이전 규칙에서 0로 끝난 수라면 그 다음에선 1개
9로 끝나서 끝 숫자에 +1하는 것도 불가능 즉 이전 규칙에서 9로 끝난 수라면 그 다음에선 1개

N=1
9로 끝나는 것 1개
1 2 3 4 5 6 7 8 9
count : 9

N=2
N=1의 규칙에서 9를 제외한 나머지에서 2개씩 나오고, 9는 1개
0으로 끝나는 것 1개
9로 끝나는 것 1개
10 12 21 23 32 34 43 45 54 56 65 67 76 78 87 89 98
count : 16 + 1 = 17

N=3 
N=2의 규칙에서 10을 제외한 나머지에서 2개씩 나오고, 10은 1개
101 121 123 210 212 232 234 321 323 343 345 ... 989 987

즉 이전 규칙에서 0과 9중 하나로 끝났다면 그 다음에는 1개만 올 수 있다.

0 0 0 - 끝자리가 0이면 그 앞에 1밖에 못옴
1 1 1
2 2 2
3 3 3 
4 4 4
5 5 5
6 6 6
7 7 7
8 8 8
9 9 9 - 끝자리가 9이면 그 앞에 8밖에 못옴

       0 1 2 3 4 5 6 7 8 9 (=1의 자릿수)
1 자리 0 1 1 1 1 1 1 1 1 1 
2 자리 1 1 2 2 2 2 2 2 2 1
3 자리 1 3 3 4 4 4 4 4 3 2
0자리 = 우측 대각선
9자리 = 좌측 대각선
1~8자리 = 양측 대각선 합
"""